<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Content negotiation with Spring Boot and React | kinow</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Content negotiation with Spring Boot and React" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A few days ago I had a bug in a system built with Spring Boot and React. The frontend application was using a REST client in React, built in a similar way to what is found in the documentation, and also in blogs. import rest from &#39;rest&#39;; const Rest = () =&gt; rest.wrap(mime); However, for one of the Spring Boot application endpoints, the React component was not working. The response seemed to be OK in the Network tab, of the browser developer tools. But the component was failing and complaining when parsing the response. Turns out that the frontend was sending the request with the header Accept: text/plain, application/json. And Spring Boot was just using its default content negotiation and returning what the frontend requested: a text plain version of, what looked like, JSON. The quick fix was to request the content as JSON in React. import rest from &#39;rest&#39;; import mime from &#39;rest/interceptor/mime&#39;; const Rest = () =&gt; rest.wrap(mime , { mime: &#39;application/json&#39; } ); Now we will revisit the backend to return the JSON content, as content, regardless of what the user asks :-) Happy hacking!" />
<meta property="og:description" content="A few days ago I had a bug in a system built with Spring Boot and React. The frontend application was using a REST client in React, built in a similar way to what is found in the documentation, and also in blogs. import rest from &#39;rest&#39;; const Rest = () =&gt; rest.wrap(mime); However, for one of the Spring Boot application endpoints, the React component was not working. The response seemed to be OK in the Network tab, of the browser developer tools. But the component was failing and complaining when parsing the response. Turns out that the frontend was sending the request with the header Accept: text/plain, application/json. And Spring Boot was just using its default content negotiation and returning what the frontend requested: a text plain version of, what looked like, JSON. The quick fix was to request the content as JSON in React. import rest from &#39;rest&#39;; import mime from &#39;rest/interceptor/mime&#39;; const Rest = () =&gt; rest.wrap(mime , { mime: &#39;application/json&#39; } ); Now we will revisit the backend to return the JSON content, as content, regardless of what the user asks :-) Happy hacking!" />
<link rel="canonical" href="https://kinoshita.eti.br/2016/11/07/content-negotiation-with-spring-boot-and-react.html" />
<meta property="og:url" content="https://kinoshita.eti.br/2016/11/07/content-negotiation-with-spring-boot-and-react.html" />
<meta property="og:site_name" content="kinow" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-11-07T00:00:00+13:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Content negotiation with Spring Boot and React" />
<script type="application/ld+json">
{"description":"A few days ago I had a bug in a system built with Spring Boot and React. The frontend application was using a REST client in React, built in a similar way to what is found in the documentation, and also in blogs. import rest from &#39;rest&#39;; const Rest = () =&gt; rest.wrap(mime); However, for one of the Spring Boot application endpoints, the React component was not working. The response seemed to be OK in the Network tab, of the browser developer tools. But the component was failing and complaining when parsing the response. Turns out that the frontend was sending the request with the header Accept: text/plain, application/json. And Spring Boot was just using its default content negotiation and returning what the frontend requested: a text plain version of, what looked like, JSON. The quick fix was to request the content as JSON in React. import rest from &#39;rest&#39;; import mime from &#39;rest/interceptor/mime&#39;; const Rest = () =&gt; rest.wrap(mime , { mime: &#39;application/json&#39; } ); Now we will revisit the backend to return the JSON content, as content, regardless of what the user asks :-) Happy hacking!","@type":"BlogPosting","url":"https://kinoshita.eti.br/2016/11/07/content-negotiation-with-spring-boot-and-react.html","headline":"Content negotiation with Spring Boot and React","datePublished":"2016-11-07T00:00:00+13:00","dateModified":"2016-11-07T00:00:00+13:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://kinoshita.eti.br/2016/11/07/content-negotiation-with-spring-boot-and-react.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/main.css" /><link type="application/atom+xml" rel="alternate" href="https://kinoshita.eti.br/feed.xml" title="kinow" /><link href="https://unpkg.com/pattern.css" rel="stylesheet" />

</head>
<body>
<div id="mobile-menu"><div class="menu">
  <ul class="menu">
    <li class="item">
      <h1 id="kinow">KINOW</h1>
    </li>
    <li class="item">
      <a href="/" class="">About</a>
    </li>
    <li class="item">
      <a href="/blog/" class="current">Blog</a>
    </li>
    <li class="item">
      <a href="/portfolio/" class="">Portfolio</a>
    </li>
    <li class="item social-media-item">
      <a href="https://www.instagram.com/brunokinoshita/" class="inline-link">
        <img src="/assets/icons/instagram.png" class="inverted-image"  alt="Instagram link" />
      </a>
      <a href="https://twitter.com/kinow/" class="inline-link">
        <img src="/assets/icons/twitter.png" class="inverted-image" alt="Twitter link" />
      </a>
      <a href="https://github.com/kinow/" class="inline-link">
        <img src="/assets/icons/github.png" class="inverted-image" alt="GitHub link" />
      </a>
    </li>
  </ul>
</div>
</div>
<div id="wrapper">
  <div id="sidebar"><div class="menu">
  <ul class="menu">
    <li class="item">
      <h1 id="kinow">KINOW</h1>
    </li>
    <li class="item">
      <a href="/" class="">About</a>
    </li>
    <li class="item">
      <a href="/blog/" class="current">Blog</a>
    </li>
    <li class="item">
      <a href="/portfolio/" class="">Portfolio</a>
    </li>
    <li class="item social-media-item">
      <a href="https://www.instagram.com/brunokinoshita/" class="inline-link">
        <img src="/assets/icons/instagram.png" class="inverted-image"  alt="Instagram link" />
      </a>
      <a href="https://twitter.com/kinow/" class="inline-link">
        <img src="/assets/icons/twitter.png" class="inverted-image" alt="Twitter link" />
      </a>
      <a href="https://github.com/kinow/" class="inline-link">
        <img src="/assets/icons/github.png" class="inverted-image" alt="GitHub link" />
      </a>
    </li>
  </ul>
</div>
</div>
  <div id="content">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Content negotiation with Spring Boot and React</h1>
    <span class="post-meta">
      <time class="dt-published" datetime="2016-11-07T00:00:00+13:00" itemprop="datePublished">Nov 7, 2016
      </time>
      <span>&mdash; star date: -306068.31.</span>
      <span>
        Number of words: 252.
      </span></span>
  </header>

  


  <div class="post-content e-content" itemprop="articleBody">
    <p>A few days ago I had a bug in a system built with Spring Boot and React. The frontend application
was using a REST client in React, built in a similar way to what is found in the documentation, and
also in blogs.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">rest</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rest</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">Rest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">rest</span><span class="p">.</span><span class="nx">wrap</span><span class="p">(</span><span class="nx">mime</span><span class="p">);</span>
</code></pre></div></div>

<p>However, for one of the Spring Boot application endpoints, the React component was not working. The
response seemed to be OK in the Network tab, of the browser developer tools. But the component was
failing and complaining when parsing the response.</p>

<p>Turns out that the frontend was sending the request with the header <code class="language-plaintext highlighter-rouge">Accept: text/plain, application/json</code>.
And Spring Boot was just using its <a href="https://spring.io/blog/2013/05/11/content-negotiation-using-spring-mvc">default content negotiation</a>
and returning what the frontend requested: a text plain version of, what looked like, JSON.</p>

<p>The quick fix was to request the content as JSON in React.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">rest</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rest</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">mime</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">rest/interceptor/mime</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">Rest</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">rest</span><span class="p">.</span><span class="nx">wrap</span><span class="p">(</span><span class="nx">mime</span> <span class="p">,</span> <span class="p">{</span> <span class="na">mime</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span> <span class="p">}</span> <span class="p">);</span>
</code></pre></div></div>

<p>Now we will revisit the backend to return the JSON content, as content, regardless of what
the user asks :-)</p>

<p>Happy hacking!</p>

  </div>

  <div class="tags"><p>Tags:&nbsp;<a class="label" href="/tag/java">java</a>.<br/></p></div>

  <a class="u-url" href="/2016/11/07/content-negotiation-with-spring-boot-and-react.html" hidden></a>
</article>

  </div>
</div>
</body>
</html>
