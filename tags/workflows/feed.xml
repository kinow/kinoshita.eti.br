<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Workflows on kinow</title><link>https://kinoshita.eti.br/tags/workflows.html</link><description>Recent content in Workflows on kinow</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Bruno P. Kinoshita All rights reserved</copyright><lastBuildDate>Sun, 21 Apr 2024 16:41:21 +0200</lastBuildDate><atom:link href="https://kinoshita.eti.br/tags/workflows/feed.xml" rel="self" type="application/rss+xml"/><item><title>Cyclic Workflows with Prefect</title><link>https://kinoshita.eti.br/2021/11/08/cyclic-workflows-with-prefect.html</link><pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2021/11/08/cyclic-workflows-with-prefect.html</guid><description>&lt;div style="width: 50%; margin: 0 auto;">
 
 
 
 &lt;figure class="feature">
 
 &lt;img
 src='https://kinoshita.eti.br/assets/posts/2021-11-08-cyclic-workflows-with-prefect/prefect.svg'
 alt='Prefect logo'
 title='Prefect logo'
 style=''
 width=''
 height=''
 />
 &lt;figcaption>&lt;/figcaption>
 
 &lt;/figure>
 

&lt;/div>
&lt;p>Last month I wrote about
&lt;a href="https://kinoshita.eti.br/2021/10/01/cyclic-workflows-with-cylc-and-stackstorm.html">Cyclic Workflows with Cylc and StackStorm&lt;/a>
and how few workflow managers support cyclic workflows.&lt;/p>
&lt;p>I was surprised today while reading Prefect documentation to see this paragraph:&lt;/p>
&lt;blockquote>
&lt;p>Most workflow frameworks act as if looping is impossible (stressing the Acyclic part of the DAG),
but it&amp;rsquo;s actually trivial to implement. We simply dynamically unroll the loop, similar to how RNN
gradients are sometimes computed.&lt;/p>
&lt;/blockquote></description></item><item><title>Cyclic Workflows with Cylc and StackStorm</title><link>https://kinoshita.eti.br/2021/10/01/cyclic-workflows-with-cylc-and-stackstorm.html</link><pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2021/10/01/cyclic-workflows-with-cylc-and-stackstorm.html</guid><description>I am aware of only two workflow managers that support cyclic workflows. Cylc and StackStorm. I won&amp;rsquo;t enter into details about these two tools, but I must note that I worked on Cylc during my employment with NIWA, in New Zealand.
In this post I will only show a very simple workflow called five first using Cylc, and then the same workflow with StackStorm.
Cylc First let&amp;rsquo;s take a look at the source code of this workflow with Cylc 8 and plot it.</description></item><item><title>Using Lumino with Vue</title><link>https://kinoshita.eti.br/2020/03/28/using-lumino-with-vue.html</link><pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2020/03/28/using-lumino-with-vue.html</guid><description>&lt;p>&lt;a href="https://github.com/jupyterlab/lumino">Lumino&lt;/a> is the engine that powers the GUI of
&lt;a href="https://github.com/jupyterlab/jupyterlab/">JupyterLab&lt;/a>. It used to be called Phosphor JS,
but some time ago there was a misunderstanding and the author gave up maintaining it.
Then JupyterLab decided to fork it under this new name.&lt;/p>



&lt;figure class="feature">

 &lt;img
 src='https://kinoshita.eti.br/assets/posts/2020-03-28-using-lumino-with-vue/demo.gif'
 alt=''
 title=''
 style=''
 width=''
 height=''
 />
 &lt;figcaption>&lt;/figcaption>

&lt;/figure>


&lt;p>The documentation is still lacking, but it works as expected, and there is already a
community supporting it. We decided to use it in &lt;a href="https://github.com/cylc/cylc-ui">Cylc UI&lt;/a>
to have tabbed panels like JupyterLab.&lt;/p>
&lt;p>&lt;a href="https://github.com/kinow/vue-lumino">This project&lt;/a> contains the part of the code of
Cylc UI that integrated Lumino and Vue. It was a suggestion from one of the maintainers
of JupyterLab, that got involved in an issue of Cylc UI. You can find this project linked
too in the Lumino project &lt;code>README&lt;/code> file.&lt;/p></description></item><item><title>Experimenting with Vuejs and Cytoscape</title><link>https://kinoshita.eti.br/2019/11/19/experimenting-with-vuejs-and-cytoscape.html</link><pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2019/11/19/experimenting-with-vuejs-and-cytoscape.html</guid><description>&lt;p>The project I work on at work had a GUI interface with Python and PyGTK, which is now being
ported to the web. We have adopted Vuejs as the JS framework, and have been building the
components required for our UI over the past months. The project is hosted
&lt;a href="https://github.com/cylc/cylc-ui">on GitHub&lt;/a> licensed under GPLv3.&lt;/p>
&lt;p>In Cylc 7, an important visualization was the workflow graph. The screenshot below is from
the design sketches done by another contributor from the UK, showing how it should look in
Cylc 8.&lt;/p>



&lt;figure class="feature">

 &lt;img
 src='https://kinoshita.eti.br/assets/posts/2019-11-19-experimenting-with-vuejs-and-cytoscape/cylc8-sketch.png'
 alt=''
 title=''
 style=''
 width=''
 height=''
 />
 &lt;figcaption>&lt;/figcaption>

&lt;/figure>


&lt;p>The first library we decided to try is Cytoscape, a well-known graph library, with use cases
in research, corporate, and other fields. One limitation of Cytoscape is that the way it renders
the graph nodes is limited.&lt;/p>
&lt;p>Limited, meaning that you won&amp;rsquo;t be able to easily add HTML, images, SVG, animation, etc. Though
not impossible.&lt;/p></description></item><item><title>Generating diagrams from a SQlite database with Python</title><link>https://kinoshita.eti.br/2019/07/28/generating-diagrams-from-a-sqlite-database-with-python.html</link><pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2019/07/28/generating-diagrams-from-a-sqlite-database-with-python.html</guid><description>&lt;figure class="feature">

 &lt;img
 src='https://kinoshita.eti.br/assets/posts/2019-07-28-generating-diagrams-from-a-sqlite-database-with-python/Amiga.png'
 alt='A 1984 Apple Macintosh drawing'
 title='A 1984 Apple Macintosh drawing'
 style='float: left; width: 30%;'
 width=''
 height=''
 />
 &lt;figcaption>A 1984 Apple Macintosh drawing&lt;/figcaption>

&lt;/figure>


&lt;p>There are tools out there that can be used to reverse engineer databases and generate diagrams. These tools
normally are GUI based. But &lt;a href="https://github.com/cylc/cylc-doc/pull/29">I needed&lt;/a> one that could be used in a
project build to generate a simple diagram for documentation.&lt;/p>
&lt;p>A tool in Python would be ideal, as that is the language the project I was working on was written in. After
searching in DuckDuckGo and PYPI, I found &lt;a href="https://pypi.org/project/ERAlchemy/">ERAlchemy&lt;/a> that
seemed to have the features I needed - kinda.&lt;/p></description></item><item><title>A look at the first implementation of GraphQL in Cylc</title><link>https://kinoshita.eti.br/2019/05/17/a-look-at-the-first-implementation-of-graphql-in-cylc.html</link><pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2019/05/17/a-look-at-the-first-implementation-of-graphql-in-cylc.html</guid><description>&lt;figure class="feature">

 &lt;img
 src='https://kinoshita.eti.br/assets/posts/2019-05-17-a-look-at-the-first-implementation-of-graphql-in-cylc/fancy-hands2.png'
 alt=''
 title=''
 style='float: right; width: 40%;'
 width=''
 height=''
 />
 &lt;figcaption>&lt;/figcaption>

&lt;/figure>


&lt;p>For Cylc 8 we are adding an initial implementation of GraphQL, to replace the previous REST API.
Besides the technologies in the API&amp;rsquo;s, another difference is that for the REST API, its main
consumer was a PyGTK GUI.&lt;/p>
&lt;p>The new GraphQL API, on the other hand, will be used mainly by a Vue.js Web application. So a
few things need to be done in a different way due to the jump from Desktop GUI to Web GUI.&lt;/p></description></item><item><title>Running Cylc tasks on PBS Torque with Docker</title><link>https://kinoshita.eti.br/2018/12/22/running-cylc-tasks-on-pbs-torque-with-docker.html</link><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2018/12/22/running-cylc-tasks-on-pbs-torque-with-docker.html</guid><description>&lt;p>A few days ago I saw &lt;a href="https://groups.google.com/forum/#!topic/cylc/dP2I1Gxqi20">a post&lt;/a> at the
Cylc Google Group, about file permissions for files generated by Cylc. The post was related to
content created by Cylc, but in an environment with PBS.&lt;/p>
&lt;p>For context, Cylc is an Open Source meta-scheduler, written in Python, that allows you to
define cycle points with dependencies. These cycle points can be simple incremental integer
numbers, or ISO8601 periods or points (e.g. run every 5 minutes, from 10 days ago until the
next year). Cylc takes care to create an execution schedule for you, and delegate that to a
system that runs your workflow. I work full time on this amazing Open Source tool!&lt;/p>
&lt;p>Such system could be the local computer in background, batch systems such as &lt;code>at&lt;/code>, or PBS.
PBS was created for NASA, to manage executing jobs taking into consideration cluster resources,
and also using queues, priorities, and other features useful for HPC programming. Later PBS
was acquired by Altair, an Open Source version OpenPBS was created, and later abandoned. And
there is another fork called PBS Torque. I first encountered PBS at the SÃ£o Paulo
University, in Brazil, where they had a &lt;a href="http://www.usp.br/hpc/puma.php">PBS Torque cluster&lt;/a>.&lt;/p>
&lt;h3 id="running-pbs-torque-with-docker">Running PBS Torque with Docker&lt;/h3>
&lt;p>Even though I have access to an environment with Cylc and with PBS, I decided to give it a try
and see how hard it would be to reproduce it with Docker. One thing that I like about this
approach is the possibility to share the work with others online. I believe it improves
communication, agility, and can be useful for posterity.&lt;/p></description></item><item><title>A couple of class diagrams of JupyterHub</title><link>https://kinoshita.eti.br/2018/10/06/a-couple-of-class-diagrams-of-jupyterhub.html</link><pubDate>Sat, 06 Oct 2018 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2018/10/06/a-couple-of-class-diagrams-of-jupyterhub.html</guid><description>&lt;p>Started on a new project last Monday. One of the tasks in this project involves a new design
for the Web layer. And as the application is quite similar to &lt;a href="https://jupyterhub.readthedocs.io/">JupyterHub&lt;/a>,
we are all learning more about its internal API and general system design.&lt;/p>
&lt;p>This post contains only two class diagrams created with PyCharm. One is actually a SQLAlchemy
ORM diagram, below.&lt;/p>
&lt;p style='text-align: center;'>
&lt;a href="https://kinoshita.eti.br/assets/posts{{page.path | remove: ".md" | remove: "_posts" }}/jupyterhub-sqlalchemy-graph.png">



&lt;figure class="feature">

 &lt;img
 src='https://kinoshita.eti.br/assets/posts/2018-10-06-a-couple-of-class-diagrams-of-jupyterhub/jupyterhub-sqlalchemy-graph.png'
 alt=''
 title=''
 style='display: inline; width: 100%;'
 width=''
 height=''
 />
 &lt;figcaption>&lt;/figcaption>

&lt;/figure>


&lt;/a>
&lt;/p></description></item><item><title>Cylc Scheduler Internals - Part 3</title><link>https://kinoshita.eti.br/2018/08/18/cylc-scheduler-internals-part-3.html</link><pubDate>Sat, 18 Aug 2018 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2018/08/18/cylc-scheduler-internals-part-3.html</guid><description>&lt;p>This is the part 3, in a series of posts about &lt;a href="https://cylc.github.io/cylc">Cylc&lt;/a>
internals. The [part 1]({% post_url 2018-07-14-cylc-scheduler-internals-part-1 %})
had the beginning of the workflow. [part 2]({% post_url 2018-07-27-cylc-scheduler-internals-part-2 %})
documented from the moment the method &lt;code>configure()&lt;/code> is called. This post will
continue right after the &lt;code>continue()&lt;/code> method returns, going on with the next method: &lt;code>run()&lt;/code>.&lt;/p>
&lt;p style='text-align: center;'>
&lt;a href="https://kinoshita.eti.br/assets/posts{{page.path | remove: ".md" | remove: "_posts" }}/cylc-scheduler_run.png">



&lt;figure class="feature">

 &lt;img
 src='https://kinoshita.eti.br/assets/posts/2018-08-18-cylc-scheduler-internals-part-3/cylc-scheduler_run.png'
 alt=''
 title=''
 style='display: inline; width: 100%;'
 width=''
 height=''
 />
 &lt;figcaption>&lt;/figcaption>

&lt;/figure>


&lt;/a>
&lt;/p></description></item><item><title>Creating a Docker container to run as a command</title><link>https://kinoshita.eti.br/2018/08/04/creating-a-docker-container-to-run-as-a-command.html</link><pubDate>Sat, 04 Aug 2018 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2018/08/04/creating-a-docker-container-to-run-as-a-command.html</guid><description>&lt;p>For the past two weeks at work I have been assigned to work on PHP projects. Though I used
PHP some time ago - especially with Code Igniter and Laravel - I have not used it in a few
years. And have been doing mostly Java nowadays.&lt;/p>
&lt;p>The complete project setup was done by co-workers. I had a PHP project, using Symfony, several
bundles and libraries, and Postgres. But it required just running a few commands to set up
AWS settings, and then fire up Docker Compose.&lt;/p></description></item><item><title>A simple Cylc suite</title><link>https://kinoshita.eti.br/2018/07/08/a-simple-cylc-suite.html</link><pubDate>Sun, 08 Jul 2018 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2018/07/08/a-simple-cylc-suite.html</guid><description>&lt;p>I have been writing more suites for &lt;a href="https://cylc.github.io/cylc/">cylc&lt;/a> lately, and found
an example that has proved to be useful for debugging certain parts of the code.&lt;/p>
&lt;p>It is an extremely simple suite, similar to what is in cylc&amp;rsquo;s documentation. It
sleeps for N seconds, and prints a message.&lt;/p></description></item><item><title>Geek Vacation 2016</title><link>https://kinoshita.eti.br/2016/04/08/geek-vacation-2016.html</link><pubDate>Fri, 08 Apr 2016 00:00:00 +0000</pubDate><guid>https://kinoshita.eti.br/2016/04/08/geek-vacation-2016.html</guid><description>I just had a two-week vacation, and I tried to use my time to rest, play some music, and complete a geek todo-list.
The list included things that I used some time ago but wanted to refresh my memory, things that I already used but never spent time reading the manuals, and other things that I saw somewhere but never actually used in any project.
Here the complete list, with the items that were completed highlighted.</description></item></channel></rss>