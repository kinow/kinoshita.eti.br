<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>What happens when you upload a Turtle file in Apache Jena Fuseki | Bruno P. Kinoshita</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="What happens when you upload a Turtle file in Apache Jena Fuseki" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I am working on an issue for Skosmos that involves preparing some Turtle files and uploading them using Apache Jena Fuseki’s web interface. The issue is now pending feedback, which gives me a moment to have fun with something else. So I decided to dig down the rabbit hole and start learning more about certain parts of the Apache Jena code base. This post will be useful to myself in the future, as a note-taking in a series, so that I remember how things work - you never know right? But hopefully this will be useful to other wanting to understand more about the code of Apache Jena. Where upload happens - SPARQL_Upload and Upload (Fuseki Core) Knowing a bit of the code base, I went straight to the SPARQL_Upload class, from the Fuseki Core module. Set up a couple of breakpoints, uploaded my file, but nothing. Then tried on its package-neighbour class, Upload. Actually, it is easier to understand seeing the class hierarchy, and knowing that when I run the application in Eclipse, it is running with Jetty, serving servlets (there is no framework like Wicket, Struts, etc, involved). Several filters are applied to the HTTP request too, like Cross Origin, Shiro, and the FusekiFilter. The latter looks at the requests to see if it includes a dataset. If a dataset is found - it is in our case - then it hands the request over to the right class to handle it. REST_Quads_RW will take care of the upload action, using the Upload class where my breakpoint stopped. Upload#incomingData() (Fuseki Core) Upload#incomingData() starts by checking the Content Type from the request. In my case it is a multipart/form-data. Then it calls its other method #fileUploadWorker(). #fileUploadWorker() creates a ServletFilterUpload, from Apache Commons FileUpload. With that, it opens a stream for the file, retrieves its name and other information, such as the content type. Ah, the content type is interesting too. It defaults to RDFXML, but what’s interesting is the comment. if ( lang == null ) // Desperate. lang = RDFLanguages.RDFXML ; Well, in this case we are getting a Lang:Turtle. So it now knows that it has a Turtle file, but it still needs to parse it. ActionLib#parse() (Fuseki Core) Upload calls ActionLib#parse(), which uses RDFParserBuilder to build a parser. It applies a nice fluent API design when doing that. RDFParser.create() .errorHandler(errorHandler) .source(input) .lang(lang) .base(base) .parse(dest); Side note to self: the `RDFParser` has a `canUse` flag. It seems to indicate the parser can be used just once. Though it looks actually it works until the stream is closed... So RDFParserBuilder will call RDFParser, which in turn will use the classes LangTurtle and LangTurtleBase. LangTurtle (ARQ) ARQ is a low level module in Jena, responsible for parsing queries, and also some of the interaction with graphs and datasets. LangTurtle extends LangTurtleBase. Their task starts by populating the prefixMap, which contains all those prefixes used in queries like rdfs, void, skos, etc. Then it will keep parsing triples until it finds an EOF. For every triple, after the Predicate-Object-List is found, it calls LangTurtle#emit(). The #emit()method creates a Triple object (Jena Core, graph package). And also a StreamRDFCountingBase to keep track of statistics to display back to the user. StreamRDFCountingBase extends StreamRDFWrapper, and wraps - as per name - other StreamRDF’s, such as ParserOutputDataset. ParserOutputDataset holds a reference to the DatasetGraph and also to the prefixMap populated earlier in LangTurtle. For each Triple that we have it will call the DatasetGraph#add method, creating a new Quad with the default graph name. Conclusion Finally, readers and streams are closed. An UploadDetails object is created holding stats collected in StreamRDFCountingBase, which are also used for logging. Upload#incomingPath() will return the UploadDetails. If there are no errors then the transaction will be committed. It involves again classes from ARQ and TDB (for journaling), but that will be for another post. The final method called in the Upload class will be detailsJson(), which returns the object as JSON. This JSON string is then finally returned to the user. So that’s it. Probably the next step will be to learn how DatasetGraph works, or maybe more about transactions in Jena. Happy hacking !" />
<meta property="og:description" content="I am working on an issue for Skosmos that involves preparing some Turtle files and uploading them using Apache Jena Fuseki’s web interface. The issue is now pending feedback, which gives me a moment to have fun with something else. So I decided to dig down the rabbit hole and start learning more about certain parts of the Apache Jena code base. This post will be useful to myself in the future, as a note-taking in a series, so that I remember how things work - you never know right? But hopefully this will be useful to other wanting to understand more about the code of Apache Jena. Where upload happens - SPARQL_Upload and Upload (Fuseki Core) Knowing a bit of the code base, I went straight to the SPARQL_Upload class, from the Fuseki Core module. Set up a couple of breakpoints, uploaded my file, but nothing. Then tried on its package-neighbour class, Upload. Actually, it is easier to understand seeing the class hierarchy, and knowing that when I run the application in Eclipse, it is running with Jetty, serving servlets (there is no framework like Wicket, Struts, etc, involved). Several filters are applied to the HTTP request too, like Cross Origin, Shiro, and the FusekiFilter. The latter looks at the requests to see if it includes a dataset. If a dataset is found - it is in our case - then it hands the request over to the right class to handle it. REST_Quads_RW will take care of the upload action, using the Upload class where my breakpoint stopped. Upload#incomingData() (Fuseki Core) Upload#incomingData() starts by checking the Content Type from the request. In my case it is a multipart/form-data. Then it calls its other method #fileUploadWorker(). #fileUploadWorker() creates a ServletFilterUpload, from Apache Commons FileUpload. With that, it opens a stream for the file, retrieves its name and other information, such as the content type. Ah, the content type is interesting too. It defaults to RDFXML, but what’s interesting is the comment. if ( lang == null ) // Desperate. lang = RDFLanguages.RDFXML ; Well, in this case we are getting a Lang:Turtle. So it now knows that it has a Turtle file, but it still needs to parse it. ActionLib#parse() (Fuseki Core) Upload calls ActionLib#parse(), which uses RDFParserBuilder to build a parser. It applies a nice fluent API design when doing that. RDFParser.create() .errorHandler(errorHandler) .source(input) .lang(lang) .base(base) .parse(dest); Side note to self: the `RDFParser` has a `canUse` flag. It seems to indicate the parser can be used just once. Though it looks actually it works until the stream is closed... So RDFParserBuilder will call RDFParser, which in turn will use the classes LangTurtle and LangTurtleBase. LangTurtle (ARQ) ARQ is a low level module in Jena, responsible for parsing queries, and also some of the interaction with graphs and datasets. LangTurtle extends LangTurtleBase. Their task starts by populating the prefixMap, which contains all those prefixes used in queries like rdfs, void, skos, etc. Then it will keep parsing triples until it finds an EOF. For every triple, after the Predicate-Object-List is found, it calls LangTurtle#emit(). The #emit()method creates a Triple object (Jena Core, graph package). And also a StreamRDFCountingBase to keep track of statistics to display back to the user. StreamRDFCountingBase extends StreamRDFWrapper, and wraps - as per name - other StreamRDF’s, such as ParserOutputDataset. ParserOutputDataset holds a reference to the DatasetGraph and also to the prefixMap populated earlier in LangTurtle. For each Triple that we have it will call the DatasetGraph#add method, creating a new Quad with the default graph name. Conclusion Finally, readers and streams are closed. An UploadDetails object is created holding stats collected in StreamRDFCountingBase, which are also used for logging. Upload#incomingPath() will return the UploadDetails. If there are no errors then the transaction will be committed. It involves again classes from ARQ and TDB (for journaling), but that will be for another post. The final method called in the Upload class will be detailsJson(), which returns the object as JSON. This JSON string is then finally returned to the user. So that’s it. Probably the next step will be to learn how DatasetGraph works, or maybe more about transactions in Jena. Happy hacking !" />
<link rel="canonical" href="https://kinoshita.eti.br/2018/05/27/what-happens-when-you-upload-a-turtle-file-in-apache-jena-fuseki.html" />
<meta property="og:url" content="https://kinoshita.eti.br/2018/05/27/what-happens-when-you-upload-a-turtle-file-in-apache-jena-fuseki.html" />
<meta property="og:site_name" content="Bruno P. Kinoshita" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-27T00:00:00+12:00" />
<script type="application/ld+json">
{"description":"I am working on an issue for Skosmos that involves preparing some Turtle files and uploading them using Apache Jena Fuseki’s web interface. The issue is now pending feedback, which gives me a moment to have fun with something else. So I decided to dig down the rabbit hole and start learning more about certain parts of the Apache Jena code base. This post will be useful to myself in the future, as a note-taking in a series, so that I remember how things work - you never know right? But hopefully this will be useful to other wanting to understand more about the code of Apache Jena. Where upload happens - SPARQL_Upload and Upload (Fuseki Core) Knowing a bit of the code base, I went straight to the SPARQL_Upload class, from the Fuseki Core module. Set up a couple of breakpoints, uploaded my file, but nothing. Then tried on its package-neighbour class, Upload. Actually, it is easier to understand seeing the class hierarchy, and knowing that when I run the application in Eclipse, it is running with Jetty, serving servlets (there is no framework like Wicket, Struts, etc, involved). Several filters are applied to the HTTP request too, like Cross Origin, Shiro, and the FusekiFilter. The latter looks at the requests to see if it includes a dataset. If a dataset is found - it is in our case - then it hands the request over to the right class to handle it. REST_Quads_RW will take care of the upload action, using the Upload class where my breakpoint stopped. Upload#incomingData() (Fuseki Core) Upload#incomingData() starts by checking the Content Type from the request. In my case it is a multipart/form-data. Then it calls its other method #fileUploadWorker(). #fileUploadWorker() creates a ServletFilterUpload, from Apache Commons FileUpload. With that, it opens a stream for the file, retrieves its name and other information, such as the content type. Ah, the content type is interesting too. It defaults to RDFXML, but what’s interesting is the comment. if ( lang == null ) // Desperate. lang = RDFLanguages.RDFXML ; Well, in this case we are getting a Lang:Turtle. So it now knows that it has a Turtle file, but it still needs to parse it. ActionLib#parse() (Fuseki Core) Upload calls ActionLib#parse(), which uses RDFParserBuilder to build a parser. It applies a nice fluent API design when doing that. RDFParser.create() .errorHandler(errorHandler) .source(input) .lang(lang) .base(base) .parse(dest); Side note to self: the `RDFParser` has a `canUse` flag. It seems to indicate the parser can be used just once. Though it looks actually it works until the stream is closed... So RDFParserBuilder will call RDFParser, which in turn will use the classes LangTurtle and LangTurtleBase. LangTurtle (ARQ) ARQ is a low level module in Jena, responsible for parsing queries, and also some of the interaction with graphs and datasets. LangTurtle extends LangTurtleBase. Their task starts by populating the prefixMap, which contains all those prefixes used in queries like rdfs, void, skos, etc. Then it will keep parsing triples until it finds an EOF. For every triple, after the Predicate-Object-List is found, it calls LangTurtle#emit(). The #emit()method creates a Triple object (Jena Core, graph package). And also a StreamRDFCountingBase to keep track of statistics to display back to the user. StreamRDFCountingBase extends StreamRDFWrapper, and wraps - as per name - other StreamRDF’s, such as ParserOutputDataset. ParserOutputDataset holds a reference to the DatasetGraph and also to the prefixMap populated earlier in LangTurtle. For each Triple that we have it will call the DatasetGraph#add method, creating a new Quad with the default graph name. Conclusion Finally, readers and streams are closed. An UploadDetails object is created holding stats collected in StreamRDFCountingBase, which are also used for logging. Upload#incomingPath() will return the UploadDetails. If there are no errors then the transaction will be committed. It involves again classes from ARQ and TDB (for journaling), but that will be for another post. The final method called in the Upload class will be detailsJson(), which returns the object as JSON. This JSON string is then finally returned to the user. So that’s it. Probably the next step will be to learn how DatasetGraph works, or maybe more about transactions in Jena. Happy hacking !","@type":"BlogPosting","url":"https://kinoshita.eti.br/2018/05/27/what-happens-when-you-upload-a-turtle-file-in-apache-jena-fuseki.html","headline":"What happens when you upload a Turtle file in Apache Jena Fuseki","dateModified":"2018-05-27T00:00:00+12:00","datePublished":"2018-05-27T00:00:00+12:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://kinoshita.eti.br/2018/05/27/what-happens-when-you-upload-a-turtle-file-in-apache-jena-fuseki.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/main.css"><link type="application/atom+xml" rel="alternate" href="https://kinoshita.eti.br/feed.xml" title="Bruno P. Kinoshita" /><link href="https://unpkg.com/pattern.css" rel="stylesheet">

</head>
<body>
<div id="mobile-menu"><div class="menu">
  <ul class="menu">
    <li class="item">
      <a href="/" aria-label="Home page link">
        <svg id="svg8" version="1.1" viewBox="0 0 58.208 9.2604" xmlns="http://www.w3.org/2000/svg" role="img"
             aria-labelledby="svg-logo-title svg-logo-desc">
          <title id="svg-logo-title">KINOSHITA image</title>
          <desc id="svg-logo-desc">A logo with the word KINOSHITA</desc>
          <g id="layer1" transform="translate(0 -287.74)">
            <g id="text817" transform="translate(-2.4568 -.23624)">
              <g id="logo" transform="matrix(2.6585 0 0 2.5911 -63.587 100.56)" fill="#000000" stroke-width=".26458px">
                <path role="presentation" id="path819"
                      d="m25.178 72.637h0.54187v2.9633h-0.54187zm0.5842 1.397 1.0964-1.397h0.635l-1.1049 1.397 1.1049 1.5663h-0.635z"/>
                <path role="presentation" id="path821" d="m27.832 72.637h0.54187v2.9633h-0.54187z"/>
                <path role="presentation" id="path823"
                      d="m29.023 72.637h0.5334l1.2658 1.9135v-1.9135h0.54187v2.9633h-0.4445l-1.3547-2.032v2.032h-0.54187z"/>
                <path role="presentation" id="path825"
                      d="m33.298 75.66q-0.4191 0-0.75353-0.1905-0.3302-0.19473-0.5207-0.54187-0.18627-0.35137-0.18627-0.80857t0.18627-0.80433q0.1905-0.35137 0.5207-0.54187 0.33443-0.19473 0.75353-0.19473t0.7493 0.19473q0.33443 0.1905 0.5207 0.54187 0.1905 0.34713 0.1905 0.80433t-0.1905 0.80857q-0.18627 0.34713-0.5207 0.54187-0.3302 0.1905-0.7493 0.1905zm0-0.52493q0.4318 0 0.6604-0.2794 0.23283-0.2794 0.23283-0.7366t-0.23283-0.7366q-0.2286-0.2794-0.6604-0.2794t-0.66463 0.2794q-0.2286 0.2794-0.2286 0.7366t0.2286 0.7366q0.23283 0.2794 0.66463 0.2794z"/>
                <path role="presentation" id="path827"
                      d="m36.091 75.66q-0.24977 0-0.53763-0.06773-0.28363-0.06773-0.4445-0.14817l0.0635-0.57573q0.5588 0.27093 0.98213 0.27093 0.22437 0 0.35137-0.08467 0.127-0.0889 0.127-0.25823 0-0.127-0.07197-0.20743-0.06773-0.08467-0.19897-0.1397-0.13123-0.05927-0.4191-0.16087-0.27093-0.09313-0.44873-0.19473-0.1778-0.10583-0.28363-0.2667-0.1016-0.1651-0.1016-0.40217 0-0.381 0.2794-0.61383t0.8001-0.23283q0.24553 0 0.48683 0.05503 0.24553 0.05503 0.44873 0.13547l-0.05503 0.55457q-0.26247-0.1143-0.4826-0.16933-0.2159-0.05927-0.4318-0.05927-0.2413 0-0.3683 0.08043t-0.127 0.23283q0 0.11853 0.06773 0.19473t0.18203 0.127q0.11853 0.0508 0.34713 0.12277 0.51223 0.16087 0.74507 0.37253 0.23707 0.20743 0.23707 0.5715 0 0.34713-0.2413 0.60537t-0.90593 0.25823z"/>
                <path role="presentation" id="path829"
                      d="m37.688 72.637h0.54187v1.1726h1.3547v-1.1726h0.54187v2.9633h-0.54187v-1.2827h-1.3547v1.2827h-0.54187z"/>
                <path role="presentation" id="path831" d="m40.78 72.637h0.54187v2.9633h-0.54187z"/>
                <path role="presentation" id="path833"
                      d="m42.546 73.162h-0.8382v-0.52493h2.2183v0.52493h-0.8382v2.4384h-0.54187z"/>
                <path role="presentation" id="path835"
                      d="m45.632 74.898h-1.0795l-0.24553 0.70273h-0.52493l1.0541-2.9633h0.51223l1.0541 2.9633h-0.52493zm-0.16933-0.47413-0.3683-1.0583-0.37253 1.0583z"/>
              </g>
            </g>
          </g>
        </svg>
      </a>
    </li>
    <li class="item">
      <a href="/blog/" class="current">Blog</a>
      <ul>
        <li class="item">
          <a href="/blog/drawing/" class="">Drawing</a>
        </li>
        <li class="item">
          <a href="/blog/languages/" class="">Languages</a>
        </li>
        <li class="item">
          <a href="/blog/music/" class="">Music</a>
        </li>
        <li class="item">
          <a href="/blog/writing/" class="">Writing</a>
        </li>
      </ul>
    </li>
    <li class="item">
      <a href="/art/" class="">Illustrations</a>
    </li>
    <li class="item">
      <a href="/maps/" class="">Maps</a>
    </li>
  </ul>
  <div id="menu-bottom">
    <p id="feed-subscribe">
      <a href="/feed.xml">
        <svg id="feed-icon" xmlns="http://www.w3.org/2000/svg" version="1.1" width="128px" height="128px"
             viewBox="0 0 256 256">
          <circle cx="68" cy="189" r="24" fill="rgba(255, 255, 255, .2)"/>
          <path d="M160 213h-34a82 82 0 0 0 -82 -82v-34a116 116 0 0 1 116 116z" fill="rgba(255, 255, 255, .2)"/>
          <path d="M184 213A140 140 0 0 0 44 73 V 38a175 175 0 0 1 175 175z" fill="rgba(255, 255, 255, .2)"/>
        </svg>
      </a>
    </p>
  </div>
</div>
</div>
<div id="wrapper">
  <div id="sidebar"><div class="menu">
  <ul class="menu">
    <li class="item">
      <a href="/" aria-label="Home page link">
        <svg id="svg8" version="1.1" viewBox="0 0 58.208 9.2604" xmlns="http://www.w3.org/2000/svg" role="img"
             aria-labelledby="svg-logo-title svg-logo-desc">
          <title id="svg-logo-title">KINOSHITA image</title>
          <desc id="svg-logo-desc">A logo with the word KINOSHITA</desc>
          <g id="layer1" transform="translate(0 -287.74)">
            <g id="text817" transform="translate(-2.4568 -.23624)">
              <g id="logo" transform="matrix(2.6585 0 0 2.5911 -63.587 100.56)" fill="#000000" stroke-width=".26458px">
                <path role="presentation" id="path819"
                      d="m25.178 72.637h0.54187v2.9633h-0.54187zm0.5842 1.397 1.0964-1.397h0.635l-1.1049 1.397 1.1049 1.5663h-0.635z"/>
                <path role="presentation" id="path821" d="m27.832 72.637h0.54187v2.9633h-0.54187z"/>
                <path role="presentation" id="path823"
                      d="m29.023 72.637h0.5334l1.2658 1.9135v-1.9135h0.54187v2.9633h-0.4445l-1.3547-2.032v2.032h-0.54187z"/>
                <path role="presentation" id="path825"
                      d="m33.298 75.66q-0.4191 0-0.75353-0.1905-0.3302-0.19473-0.5207-0.54187-0.18627-0.35137-0.18627-0.80857t0.18627-0.80433q0.1905-0.35137 0.5207-0.54187 0.33443-0.19473 0.75353-0.19473t0.7493 0.19473q0.33443 0.1905 0.5207 0.54187 0.1905 0.34713 0.1905 0.80433t-0.1905 0.80857q-0.18627 0.34713-0.5207 0.54187-0.3302 0.1905-0.7493 0.1905zm0-0.52493q0.4318 0 0.6604-0.2794 0.23283-0.2794 0.23283-0.7366t-0.23283-0.7366q-0.2286-0.2794-0.6604-0.2794t-0.66463 0.2794q-0.2286 0.2794-0.2286 0.7366t0.2286 0.7366q0.23283 0.2794 0.66463 0.2794z"/>
                <path role="presentation" id="path827"
                      d="m36.091 75.66q-0.24977 0-0.53763-0.06773-0.28363-0.06773-0.4445-0.14817l0.0635-0.57573q0.5588 0.27093 0.98213 0.27093 0.22437 0 0.35137-0.08467 0.127-0.0889 0.127-0.25823 0-0.127-0.07197-0.20743-0.06773-0.08467-0.19897-0.1397-0.13123-0.05927-0.4191-0.16087-0.27093-0.09313-0.44873-0.19473-0.1778-0.10583-0.28363-0.2667-0.1016-0.1651-0.1016-0.40217 0-0.381 0.2794-0.61383t0.8001-0.23283q0.24553 0 0.48683 0.05503 0.24553 0.05503 0.44873 0.13547l-0.05503 0.55457q-0.26247-0.1143-0.4826-0.16933-0.2159-0.05927-0.4318-0.05927-0.2413 0-0.3683 0.08043t-0.127 0.23283q0 0.11853 0.06773 0.19473t0.18203 0.127q0.11853 0.0508 0.34713 0.12277 0.51223 0.16087 0.74507 0.37253 0.23707 0.20743 0.23707 0.5715 0 0.34713-0.2413 0.60537t-0.90593 0.25823z"/>
                <path role="presentation" id="path829"
                      d="m37.688 72.637h0.54187v1.1726h1.3547v-1.1726h0.54187v2.9633h-0.54187v-1.2827h-1.3547v1.2827h-0.54187z"/>
                <path role="presentation" id="path831" d="m40.78 72.637h0.54187v2.9633h-0.54187z"/>
                <path role="presentation" id="path833"
                      d="m42.546 73.162h-0.8382v-0.52493h2.2183v0.52493h-0.8382v2.4384h-0.54187z"/>
                <path role="presentation" id="path835"
                      d="m45.632 74.898h-1.0795l-0.24553 0.70273h-0.52493l1.0541-2.9633h0.51223l1.0541 2.9633h-0.52493zm-0.16933-0.47413-0.3683-1.0583-0.37253 1.0583z"/>
              </g>
            </g>
          </g>
        </svg>
      </a>
    </li>
    <li class="item">
      <a href="/blog/" class="current">Blog</a>
      <ul>
        <li class="item">
          <a href="/blog/drawing/" class="">Drawing</a>
        </li>
        <li class="item">
          <a href="/blog/languages/" class="">Languages</a>
        </li>
        <li class="item">
          <a href="/blog/music/" class="">Music</a>
        </li>
        <li class="item">
          <a href="/blog/writing/" class="">Writing</a>
        </li>
      </ul>
    </li>
    <li class="item">
      <a href="/art/" class="">Illustrations</a>
    </li>
    <li class="item">
      <a href="/maps/" class="">Maps</a>
    </li>
  </ul>
  <div id="menu-bottom">
    <p id="feed-subscribe">
      <a href="/feed.xml">
        <svg id="feed-icon" xmlns="http://www.w3.org/2000/svg" version="1.1" width="128px" height="128px"
             viewBox="0 0 256 256">
          <circle cx="68" cy="189" r="24" fill="rgba(255, 255, 255, .2)"/>
          <path d="M160 213h-34a82 82 0 0 0 -82 -82v-34a116 116 0 0 1 116 116z" fill="rgba(255, 255, 255, .2)"/>
          <path d="M184 213A140 140 0 0 0 44 73 V 38a175 175 0 0 1 175 175z" fill="rgba(255, 255, 255, .2)"/>
        </svg>
      </a>
    </p>
  </div>
</div>
</div>
  <div id="content">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">What happens when you upload a Turtle file in Apache Jena Fuseki</h1>
    <span class="post-meta">
      <time class="dt-published" datetime="2018-05-27T00:00:00+12:00" itemprop="datePublished">May 27, 2018
      </time>
      <span>&mdash; star date: -304515.07.</span>
      <span>
        Number of words: 891.
      </span></span>
  </header>

  <ul>
  <li><a href="#where-upload-happens---sparql_upload-and-upload-fuseki-core">Where upload happens - SPARQL_Upload and Upload (Fuseki Core)</a></li>
  <li><a href="#uploadincomingdata-fuseki-core">Upload#incomingData() (Fuseki Core)</a></li>
  <li><a href="#actionlibparse-fuseki-core">ActionLib#parse() (Fuseki Core)</a></li>
  <li><a href="#langturtle-arq">LangTurtle (ARQ)</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>


  <div class="post-content e-content" itemprop="articleBody">
    <p>I am working on <a href="https://github.com/NatLibFi/Skosmos/issues/738">an issue for Skosmos</a>
that involves preparing some <a href="https://www.w3.org/TR/turtle/">Turtle</a> files and uploading
them using Apache Jena Fuseki’s web interface.</p>

<p>The issue is now pending feedback, which gives me a moment to have fun with
something else. So I decided to dig down the rabbit hole and start learning more
about certain parts of the Apache Jena code base.</p>

<p style="text-align: center;">
<img style="display: inline; width: 600px;" class="ui image" src="/assets/posts/2018-05-27-what-happens-when-you-upload-a-turtle-file-in-apache-jena-fuseki/browser.png" />
</p>

<p>This post will be useful to myself in the future, as a note-taking in a series, so that I
remember how things work - you never know right? But hopefully this will be useful
to other wanting to understand more about the code of Apache Jena.</p>

<h3 id="where-upload-happens---sparql_upload-and-upload-fuseki-core">Where upload happens - SPARQL_Upload and Upload (Fuseki Core)</h3>

<p>Knowing a bit of the code base, I went straight to the <code class="language-plaintext highlighter-rouge">SPARQL_Upload</code> class,
from the Fuseki Core module. Set up a couple of breakpoints, uploaded my file,
but nothing. Then tried on its package-neighbour class, <code class="language-plaintext highlighter-rouge">Upload</code>.</p>

<p>Actually, it is easier to understand seeing the class hierarchy, and knowing
that when I run the application in Eclipse, it is running with Jetty, serving
servlets (there is no framework like Wicket, Struts, etc, involved).</p>

<p style="text-align: center;">
<img style="display: inline; width: 600px;" class="ui image" src="/assets/posts/2018-05-27-what-happens-when-you-upload-a-turtle-file-in-apache-jena-fuseki/class-hierarchy.png" />
</p>

<p>Several filters are applied to the HTTP request too, like Cross Origin, Shiro, and
the <code class="language-plaintext highlighter-rouge">FusekiFilter</code>. The latter looks at the requests to see if it includes a dataset.
If a dataset is found - it is in our case - then it hands the request over to
the right class to handle it.</p>

<p>REST_Quads_RW will take care of the upload action, using the <code class="language-plaintext highlighter-rouge">Upload</code> class where my
breakpoint stopped.</p>

<h3 id="uploadincomingdata-fuseki-core">Upload#incomingData() (Fuseki Core)</h3>

<p><code class="language-plaintext highlighter-rouge">Upload#incomingData()</code> starts by checking the Content Type from the request. In my case
it is a <code class="language-plaintext highlighter-rouge">multipart/form-data</code>. Then it calls its other method <code class="language-plaintext highlighter-rouge">#fileUploadWorker()</code>.</p>

<p><code class="language-plaintext highlighter-rouge">#fileUploadWorker()</code> creates a <code class="language-plaintext highlighter-rouge">ServletFilterUpload</code>, from Apache Commons FileUpload.
With that, it opens a stream for the file, retrieves its name and other information,
such as the content type.</p>

<p>Ah, the content type is interesting too. It defaults to <code class="language-plaintext highlighter-rouge">RDFXML</code>, but what’s interesting
is the comment.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span> <span class="n">lang</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">)</span>
    <span class="c1">// Desperate.</span>
    <span class="n">lang</span> <span class="o">=</span> <span class="nc">RDFLanguages</span><span class="o">.</span><span class="na">RDFXML</span> <span class="o">;</span>
</code></pre></div></div>

<p>Well, in this case we are getting a <code class="language-plaintext highlighter-rouge">Lang:Turtle</code>. So it now knows that it has a Turtle
file, but it still needs to parse it.</p>

<h3 id="actionlibparse-fuseki-core">ActionLib#parse() (Fuseki Core)</h3>

<p><code class="language-plaintext highlighter-rouge">Upload</code> calls <code class="language-plaintext highlighter-rouge">ActionLib#parse()</code>, which uses <code class="language-plaintext highlighter-rouge">RDFParserBuilder</code> to build a parser.
It applies a nice fluent API design when doing that.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">RDFParser</span><span class="o">.</span><span class="na">create</span><span class="o">()</span>
    <span class="o">.</span><span class="na">errorHandler</span><span class="o">(</span><span class="n">errorHandler</span><span class="o">)</span>
    <span class="o">.</span><span class="na">source</span><span class="o">(</span><span class="n">input</span><span class="o">)</span>
    <span class="o">.</span><span class="na">lang</span><span class="o">(</span><span class="n">lang</span><span class="o">)</span>
    <span class="o">.</span><span class="na">base</span><span class="o">(</span><span class="n">base</span><span class="o">)</span>
    <span class="o">.</span><span class="na">parse</span><span class="o">(</span><span class="n">dest</span><span class="o">);</span>
</code></pre></div></div>

<blockquote>Side note to self: the `RDFParser` has a `canUse` flag. It seems to indicate
the parser can be used just once. Though it looks actually it works until the stream
is closed...</blockquote>

<p>So <code class="language-plaintext highlighter-rouge">RDFParserBuilder</code> will call <code class="language-plaintext highlighter-rouge">RDFParser</code>, which in turn will use the
classes <code class="language-plaintext highlighter-rouge">LangTurtle</code> and <code class="language-plaintext highlighter-rouge">LangTurtleBase</code>.</p>

<h3 id="langturtle-arq">LangTurtle (ARQ)</h3>

<p>ARQ is a low level module in Jena, responsible for parsing queries, and also
some of the interaction with graphs and datasets.</p>

<p><code class="language-plaintext highlighter-rouge">LangTurtle</code> extends <code class="language-plaintext highlighter-rouge">LangTurtleBase</code>. Their task starts by populating
the <code class="language-plaintext highlighter-rouge">prefixMap</code>, which contains all those prefixes used in queries like
<code class="language-plaintext highlighter-rouge">rdfs</code>, <code class="language-plaintext highlighter-rouge">void</code>, <code class="language-plaintext highlighter-rouge">skos</code>, <code class="language-plaintext highlighter-rouge">etc</code>.</p>

<p>Then it will keep parsing <strong>triples</strong> until it finds an <code class="language-plaintext highlighter-rouge">EOF</code>. For every
triple, after the <em>Predicate-Object-List</em> is found, it calls
<code class="language-plaintext highlighter-rouge">LangTurtle#emit()</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">#emit()</code>method creates a <code class="language-plaintext highlighter-rouge">Triple</code> object (Jena Core, graph package).
And also a <code class="language-plaintext highlighter-rouge">StreamRDFCountingBase</code> to keep track of statistics to display
back to the user.</p>

<p style="text-align: center;">
<img style="display: inline; width: 600px;" class="ui image" src="/assets/posts/2018-05-27-what-happens-when-you-upload-a-turtle-file-in-apache-jena-fuseki/eclipse.png" />
</p>

<p><code class="language-plaintext highlighter-rouge">StreamRDFCountingBase</code> extends <code class="language-plaintext highlighter-rouge">StreamRDFWrapper</code>, and wraps - as per name -
other <code class="language-plaintext highlighter-rouge">StreamRDF</code>’s, such as <code class="language-plaintext highlighter-rouge">ParserOutputDataset</code>.</p>

<p><code class="language-plaintext highlighter-rouge">ParserOutputDataset</code> holds a reference to the <code class="language-plaintext highlighter-rouge">DatasetGraph</code> and also to the
<code class="language-plaintext highlighter-rouge">prefixMap</code> populated earlier in <code class="language-plaintext highlighter-rouge">LangTurtle</code>. For each <code class="language-plaintext highlighter-rouge">Triple</code> that we have
it will call the <code class="language-plaintext highlighter-rouge">DatasetGraph#add</code> method, creating a new <em>Quad</em> with the
default graph name.</p>

<h3 id="conclusion">Conclusion</h3>

<p>Finally, readers and streams are closed. An <code class="language-plaintext highlighter-rouge">UploadDetails</code> object is created
holding stats collected in <code class="language-plaintext highlighter-rouge">StreamRDFCountingBase</code>, which are also used for
logging.</p>

<p><code class="language-plaintext highlighter-rouge">Upload#incomingPath()</code> will return the <code class="language-plaintext highlighter-rouge">UploadDetails</code>. If there are no errors
then the transaction will be committed. It involves again classes from ARQ and
TDB (for journaling), but that will be for another post.</p>

<p>The final method called in the <code class="language-plaintext highlighter-rouge">Upload</code> class will be <code class="language-plaintext highlighter-rouge">detailsJson()</code>, which
returns the object as JSON. This JSON string is then finally returned to the
user.</p>

<p>So that’s it. Probably the next step will be to learn how <code class="language-plaintext highlighter-rouge">DatasetGraph</code> works,
or maybe more about transactions in Jena.</p>

<p>Happy hacking !</p>

  </div>

  <div class="tags">
    <p>
      Published May 27, 2018 in &ldquo;blog&rdquo; and tagged&nbsp;<a class="label" href="/tags#apache software foundation">apache software foundation</a>,&nbsp;<a class="label" href="/tags#jena">jena</a>,&nbsp;<a class="label" href="/tags#opensource">opensource</a>,&nbsp;<a class="label" href="/tags#programming">programming</a>. Number of words: 891.
    </p>
  </div>

  <a class="u-url" href="/2018/05/27/what-happens-when-you-upload-a-turtle-file-in-apache-jena-fuseki.html" hidden></a>
</article>

  </div>
</div>
</body>
</html>
