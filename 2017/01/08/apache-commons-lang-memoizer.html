<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Apache Commons Lang: Memoizer | Bruno P. Kinoshita</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Apache Commons Lang: Memoizer" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The current release of Apache Commons Lang is 3.5. The upcoming release, probably 3.6, will include a new feature, added in a pull request: a Memoizer implementation. Check out the ticket LANG-740 for more about the implementation being added to [lang]. The book Java Concurrency in Practice introduces readers to the Memoizer, and has also a public domain implementation available for download (besides that, the book has also lots of other interesting topics!). In summary, Memoizer is a simple cache, that will store the result of a computation. It receives a Computable object, responsible for doing something that will be stored by the Memoizer. Here’s a simple code to illustrate how that will work in your Java code. // Computation to be stored in the cache Computable&lt;String, String&gt; getFormattedCurrentDate = new Computable&lt;String, String&gt;() { @Override public String compute(String fmt) throws InterruptedException { return new SimpleDateFormat(fmt).format(new Date()); } }; // Our memoizer Memoizer&lt;String, String&gt; dateCache = new Memoizer&lt;&gt;(getFormattedCurrentDate); // To illustrate its use for (int i = 0; i &lt; 10; i++) { try { // S -&gt; Millisecond System.out.println(dateCache.compute(&quot;HH:mm:ss:S Z dd/MM/YYYY&quot;)); // Regardless of this sleep call, we get the same result every iteration Thread.sleep(1500); } catch (InterruptedException e) { e.printStackTrace(); } } The computable created (getFormattedCurrentDate) will be called only once, and stored in a map. The parameter passed in the #compute() method will be used as key in the map. So choose your parameter wisely :-) The output of the example will be similar to the following one. 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 In the example above I used a for-loop to illustrate what will happen. Even though we call the memoizer #compute() method several times, followed by Thread#sleep(); only one result, the first to be computed, will be returned. So that’s all for today. Hope you learned something about this new class, that must be available in the next release of Apache Commons Lang. Happy hacking! ps: [lang] uses Java 7, so that is why we do not have a functional instead of the Comparable" />
<meta property="og:description" content="The current release of Apache Commons Lang is 3.5. The upcoming release, probably 3.6, will include a new feature, added in a pull request: a Memoizer implementation. Check out the ticket LANG-740 for more about the implementation being added to [lang]. The book Java Concurrency in Practice introduces readers to the Memoizer, and has also a public domain implementation available for download (besides that, the book has also lots of other interesting topics!). In summary, Memoizer is a simple cache, that will store the result of a computation. It receives a Computable object, responsible for doing something that will be stored by the Memoizer. Here’s a simple code to illustrate how that will work in your Java code. // Computation to be stored in the cache Computable&lt;String, String&gt; getFormattedCurrentDate = new Computable&lt;String, String&gt;() { @Override public String compute(String fmt) throws InterruptedException { return new SimpleDateFormat(fmt).format(new Date()); } }; // Our memoizer Memoizer&lt;String, String&gt; dateCache = new Memoizer&lt;&gt;(getFormattedCurrentDate); // To illustrate its use for (int i = 0; i &lt; 10; i++) { try { // S -&gt; Millisecond System.out.println(dateCache.compute(&quot;HH:mm:ss:S Z dd/MM/YYYY&quot;)); // Regardless of this sleep call, we get the same result every iteration Thread.sleep(1500); } catch (InterruptedException e) { e.printStackTrace(); } } The computable created (getFormattedCurrentDate) will be called only once, and stored in a map. The parameter passed in the #compute() method will be used as key in the map. So choose your parameter wisely :-) The output of the example will be similar to the following one. 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 In the example above I used a for-loop to illustrate what will happen. Even though we call the memoizer #compute() method several times, followed by Thread#sleep(); only one result, the first to be computed, will be returned. So that’s all for today. Hope you learned something about this new class, that must be available in the next release of Apache Commons Lang. Happy hacking! ps: [lang] uses Java 7, so that is why we do not have a functional instead of the Comparable" />
<link rel="canonical" href="https://kinoshita.eti.br/2017/01/08/apache-commons-lang-memoizer.html" />
<meta property="og:url" content="https://kinoshita.eti.br/2017/01/08/apache-commons-lang-memoizer.html" />
<meta property="og:site_name" content="Bruno P. Kinoshita" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-08T00:00:00+13:00" />
<script type="application/ld+json">
{"description":"The current release of Apache Commons Lang is 3.5. The upcoming release, probably 3.6, will include a new feature, added in a pull request: a Memoizer implementation. Check out the ticket LANG-740 for more about the implementation being added to [lang]. The book Java Concurrency in Practice introduces readers to the Memoizer, and has also a public domain implementation available for download (besides that, the book has also lots of other interesting topics!). In summary, Memoizer is a simple cache, that will store the result of a computation. It receives a Computable object, responsible for doing something that will be stored by the Memoizer. Here’s a simple code to illustrate how that will work in your Java code. // Computation to be stored in the cache Computable&lt;String, String&gt; getFormattedCurrentDate = new Computable&lt;String, String&gt;() { @Override public String compute(String fmt) throws InterruptedException { return new SimpleDateFormat(fmt).format(new Date()); } }; // Our memoizer Memoizer&lt;String, String&gt; dateCache = new Memoizer&lt;&gt;(getFormattedCurrentDate); // To illustrate its use for (int i = 0; i &lt; 10; i++) { try { // S -&gt; Millisecond System.out.println(dateCache.compute(&quot;HH:mm:ss:S Z dd/MM/YYYY&quot;)); // Regardless of this sleep call, we get the same result every iteration Thread.sleep(1500); } catch (InterruptedException e) { e.printStackTrace(); } } The computable created (getFormattedCurrentDate) will be called only once, and stored in a map. The parameter passed in the #compute() method will be used as key in the map. So choose your parameter wisely :-) The output of the example will be similar to the following one. 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 19:15:57:854 +1300 08/01/2017 In the example above I used a for-loop to illustrate what will happen. Even though we call the memoizer #compute() method several times, followed by Thread#sleep(); only one result, the first to be computed, will be returned. So that’s all for today. Hope you learned something about this new class, that must be available in the next release of Apache Commons Lang. Happy hacking! ps: [lang] uses Java 7, so that is why we do not have a functional instead of the Comparable","@type":"BlogPosting","url":"https://kinoshita.eti.br/2017/01/08/apache-commons-lang-memoizer.html","headline":"Apache Commons Lang: Memoizer","dateModified":"2017-01-08T00:00:00+13:00","datePublished":"2017-01-08T00:00:00+13:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://kinoshita.eti.br/2017/01/08/apache-commons-lang-memoizer.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/main.css"><link type="application/atom+xml" rel="alternate" href="https://kinoshita.eti.br/feed.xml" title="Bruno P. Kinoshita" /><link href="https://unpkg.com/pattern.css" rel="stylesheet">

</head>
<body>
<div id="mobile-menu"><div class="menu">
  <ul class="menu">
    <li class="item">
      <h1 id="kinow">KINOW</h1>
    </li>
    <li class="item">
      <a href="/" class="">About</a>
    </li>
    <li class="item">
      <a href="/blog/" class="current">Blog</a>
    </li>
    <li class="item">
      <a href="/portfolio/" class="">Portfolio</a>
    </li>
  </ul>
</div>
</div>
<div id="wrapper">
  <div id="sidebar"><div class="menu">
  <ul class="menu">
    <li class="item">
      <h1 id="kinow">KINOW</h1>
    </li>
    <li class="item">
      <a href="/" class="">About</a>
    </li>
    <li class="item">
      <a href="/blog/" class="current">Blog</a>
    </li>
    <li class="item">
      <a href="/portfolio/" class="">Portfolio</a>
    </li>
  </ul>
</div>
</div>
  <div id="content">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Apache Commons Lang: Memoizer</h1>
    <span class="post-meta">
      <time class="dt-published" datetime="2017-01-08T00:00:00+13:00" itemprop="datePublished">Jan 8, 2017
      </time>
      <span>&mdash; star date: -305895.89.</span>
      <span>
        Number of words: 483.
      </span></span>
  </header>

  


  <div class="post-content e-content" itemprop="articleBody">
    <p>The current release of <a href="https://commons.apache.org/proper/commons-lang/">Apache Commons Lang</a>
is <strong>3.5</strong>. The upcoming release, probably 3.6,
will include a new feature, added in a
<a href="https://github.com/apache/commons-lang/pull/203">pull request</a>:
<strong>a Memoizer implementation</strong>. Check out the ticket <a href="https://issues.apache.org/jira/browse/LANG-740">LANG-740</a>
for more about the implementation being added to [lang].</p>

<p>The book <a href="http://jcip.net/">Java Concurrency in Practice</a> introduces readers to the Memoizer,
and has also a <a href="http://jcip.net/listings/Memoizer.java">public domain implementation available for download</a>
(besides that, the book has also lots of other interesting topics!).</p>

<p>In summary, Memoizer is a simple cache, that will store the result of
a computation. It receives a Computable object, responsible for doing something
that will be stored by the Memoizer. Here’s a simple code to illustrate how that
will work in your Java code.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Computation to be stored in the cache</span>
<span class="nc">Computable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">getFormattedCurrentDate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Computable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">compute</span><span class="o">(</span><span class="nc">String</span> <span class="n">fmt</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">SimpleDateFormat</span><span class="o">(</span><span class="n">fmt</span><span class="o">).</span><span class="na">format</span><span class="o">(</span><span class="k">new</span> <span class="nc">Date</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">};</span>

<span class="c1">// Our memoizer</span>
<span class="nc">Memoizer</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">dateCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Memoizer</span><span class="o">&lt;&gt;(</span><span class="n">getFormattedCurrentDate</span><span class="o">);</span>

<span class="c1">// To illustrate its use</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// S -&gt; Millisecond</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dateCache</span><span class="o">.</span><span class="na">compute</span><span class="o">(</span><span class="s">"HH:mm:ss:S Z dd/MM/YYYY"</span><span class="o">));</span>
        <span class="c1">// Regardless of this sleep call, we get the same result every iteration</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1500</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The computable created (<em>getFormattedCurrentDate</em>) will be called only once, and stored in
a map. The parameter passed in the <em>#compute()</em> method will be used as key in the map.
So choose your parameter wisely :-) The output of the example will be similar to the following one.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
19:15:57:854 +1300 08/01/2017
</code></pre></div></div>

<p>In the example above I used a <em>for-loop</em> to illustrate what will happen. Even though we call
the memoizer <em>#compute()</em> method several times, followed by
<em>Thread#sleep()</em>; only one result, the first to be computed, will be returned.</p>

<p>So that’s all for today. Hope you learned something about this new class, that must
be available in the next release of Apache Commons Lang.</p>

<p>Happy hacking!</p>

<p>ps: [lang] uses Java 7, so that is why we do not have a functional instead of the Comparable</p>

  </div>

  <div class="tags">
    <p>
      Published Jan 8, 2017 in &ldquo;blog&rdquo; and tagged&nbsp;<a class="label" href="/tags#java">java</a>,&nbsp;<a class="label" href="/tags#programming">programming</a>,&nbsp;<a class="label" href="/tags#apache software foundation">apache software foundation</a>. Number of words: 483.
    </p>
  </div>

  <a class="u-url" href="/2017/01/08/apache-commons-lang-memoizer.html" hidden></a>
</article>

  </div>
</div>
</body>
</html>
