<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Writing a binary parser in Python: NumPy vs. Construct | kinow</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Writing a binary parser in Python: NumPy vs. Construct" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Some time ago I worked with researchers to write a parser for an old data format. The data was generated by device (radiosonde) using the vendor (Vaisala) specific binary format. One of the researchers told me someone had written a parser for his work, and shared it on GitHub. To be honest, that was my first time parsing data in binary with Python. Did that before with C, C++, Perl, and Java, but never with Python. The code on GitHub used NumPy and looked similar to this one. import numpy as np parse_header = np.dtype( [ ((&#39;field_a&#39;, &#39;b1&#39;), (&#39;field_b&#39;, &#39;17b1&#39;) ] ) with open(&#39;input.dat&#39;, &#39;rb&#39;) as f: header = np.fromfile(f, dtype=parse_header, count=1) # ... And it indeed worked fine. But in the end I used the code - after contacting the author and letting him know what I was about to do - as reference together with an old specification document for the format, and created a parser with Construct. From Construct’s website: Construct is a powerful declarative parser (and builder) for binary data. This is what the code with construct looked like. from construct import * parse_header = Struct(&quot;parse_header&quot;, Enum(Byte(&quot;file_ready&quot;), READY = 1, NOT_READY = 0, _default_ = &quot;UNKNOWN&quot;, ), Bytes(&quot;reserved&quot;, 17) ) # ... parse_contents = Struct(&quot;parse_contents&quot;, parse_header, Range(mincount=1, maxcout=5, subcon=pre_data), OptionalGreedyRange(detailed_data) ) with open(&#39;input.dat&#39;, &#39;rb&#39;) as f: parse_results = parse_contents.parse_stream(fid) # ... Writing the parser with NumPy or Construct would achieve the same result. However, in the end this came down to personal preference, and my point of view as Software Engineer. This is the description of NumPy. NumPy is the fundamental package for scientific computing with Python. NumPy is a project tailored for scientific computing, with a focus on linear algebra, N-dimensional arrays, and so it goes. While it contains code that can parse binary data, the footprint added to a project that includes it as dependency is quite big. The parser written with NumPy wasn’t using 5% of the NumPy code base. Probably less than 1%. Updates to NumPy could break the application compatibility, even if the update came due to some new matrix operation added to NumPy through some external and missing dependency. In Java something similar happens with Google Guava. While I use it some times, most of the times I find myself using one of the Apache Commons libraries, or another dependency with just what I need. To avoid including unnecessary code to my application. If you prefer to use NumPy that’s fine too :-) I just had the time enough to rewrite it instead of using the NumPy (took a couple of hours). In other cases it may still make sense to use another tool or library, even if it was not made specifically for the job ¯\(ツ)/¯ ♥ Open Source" />
<meta property="og:description" content="Some time ago I worked with researchers to write a parser for an old data format. The data was generated by device (radiosonde) using the vendor (Vaisala) specific binary format. One of the researchers told me someone had written a parser for his work, and shared it on GitHub. To be honest, that was my first time parsing data in binary with Python. Did that before with C, C++, Perl, and Java, but never with Python. The code on GitHub used NumPy and looked similar to this one. import numpy as np parse_header = np.dtype( [ ((&#39;field_a&#39;, &#39;b1&#39;), (&#39;field_b&#39;, &#39;17b1&#39;) ] ) with open(&#39;input.dat&#39;, &#39;rb&#39;) as f: header = np.fromfile(f, dtype=parse_header, count=1) # ... And it indeed worked fine. But in the end I used the code - after contacting the author and letting him know what I was about to do - as reference together with an old specification document for the format, and created a parser with Construct. From Construct’s website: Construct is a powerful declarative parser (and builder) for binary data. This is what the code with construct looked like. from construct import * parse_header = Struct(&quot;parse_header&quot;, Enum(Byte(&quot;file_ready&quot;), READY = 1, NOT_READY = 0, _default_ = &quot;UNKNOWN&quot;, ), Bytes(&quot;reserved&quot;, 17) ) # ... parse_contents = Struct(&quot;parse_contents&quot;, parse_header, Range(mincount=1, maxcout=5, subcon=pre_data), OptionalGreedyRange(detailed_data) ) with open(&#39;input.dat&#39;, &#39;rb&#39;) as f: parse_results = parse_contents.parse_stream(fid) # ... Writing the parser with NumPy or Construct would achieve the same result. However, in the end this came down to personal preference, and my point of view as Software Engineer. This is the description of NumPy. NumPy is the fundamental package for scientific computing with Python. NumPy is a project tailored for scientific computing, with a focus on linear algebra, N-dimensional arrays, and so it goes. While it contains code that can parse binary data, the footprint added to a project that includes it as dependency is quite big. The parser written with NumPy wasn’t using 5% of the NumPy code base. Probably less than 1%. Updates to NumPy could break the application compatibility, even if the update came due to some new matrix operation added to NumPy through some external and missing dependency. In Java something similar happens with Google Guava. While I use it some times, most of the times I find myself using one of the Apache Commons libraries, or another dependency with just what I need. To avoid including unnecessary code to my application. If you prefer to use NumPy that’s fine too :-) I just had the time enough to rewrite it instead of using the NumPy (took a couple of hours). In other cases it may still make sense to use another tool or library, even if it was not made specifically for the job ¯\(ツ)/¯ ♥ Open Source" />
<link rel="canonical" href="https://kinoshita.eti.br/2017/04/14/writing-a-binary-parser-in-python-numpy-vs-construct.html" />
<meta property="og:url" content="https://kinoshita.eti.br/2017/04/14/writing-a-binary-parser-in-python-numpy-vs-construct.html" />
<meta property="og:site_name" content="kinow" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-04-14T00:00:00+12:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Writing a binary parser in Python: NumPy vs. Construct" />
<script type="application/ld+json">
{"description":"Some time ago I worked with researchers to write a parser for an old data format. The data was generated by device (radiosonde) using the vendor (Vaisala) specific binary format. One of the researchers told me someone had written a parser for his work, and shared it on GitHub. To be honest, that was my first time parsing data in binary with Python. Did that before with C, C++, Perl, and Java, but never with Python. The code on GitHub used NumPy and looked similar to this one. import numpy as np parse_header = np.dtype( [ ((&#39;field_a&#39;, &#39;b1&#39;), (&#39;field_b&#39;, &#39;17b1&#39;) ] ) with open(&#39;input.dat&#39;, &#39;rb&#39;) as f: header = np.fromfile(f, dtype=parse_header, count=1) # ... And it indeed worked fine. But in the end I used the code - after contacting the author and letting him know what I was about to do - as reference together with an old specification document for the format, and created a parser with Construct. From Construct’s website: Construct is a powerful declarative parser (and builder) for binary data. This is what the code with construct looked like. from construct import * parse_header = Struct(&quot;parse_header&quot;, Enum(Byte(&quot;file_ready&quot;), READY = 1, NOT_READY = 0, _default_ = &quot;UNKNOWN&quot;, ), Bytes(&quot;reserved&quot;, 17) ) # ... parse_contents = Struct(&quot;parse_contents&quot;, parse_header, Range(mincount=1, maxcout=5, subcon=pre_data), OptionalGreedyRange(detailed_data) ) with open(&#39;input.dat&#39;, &#39;rb&#39;) as f: parse_results = parse_contents.parse_stream(fid) # ... Writing the parser with NumPy or Construct would achieve the same result. However, in the end this came down to personal preference, and my point of view as Software Engineer. This is the description of NumPy. NumPy is the fundamental package for scientific computing with Python. NumPy is a project tailored for scientific computing, with a focus on linear algebra, N-dimensional arrays, and so it goes. While it contains code that can parse binary data, the footprint added to a project that includes it as dependency is quite big. The parser written with NumPy wasn’t using 5% of the NumPy code base. Probably less than 1%. Updates to NumPy could break the application compatibility, even if the update came due to some new matrix operation added to NumPy through some external and missing dependency. In Java something similar happens with Google Guava. While I use it some times, most of the times I find myself using one of the Apache Commons libraries, or another dependency with just what I need. To avoid including unnecessary code to my application. If you prefer to use NumPy that’s fine too :-) I just had the time enough to rewrite it instead of using the NumPy (took a couple of hours). In other cases it may still make sense to use another tool or library, even if it was not made specifically for the job ¯\\(ツ)/¯ ♥ Open Source","@type":"BlogPosting","url":"https://kinoshita.eti.br/2017/04/14/writing-a-binary-parser-in-python-numpy-vs-construct.html","headline":"Writing a binary parser in Python: NumPy vs. Construct","datePublished":"2017-04-14T00:00:00+12:00","dateModified":"2017-04-14T00:00:00+12:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://kinoshita.eti.br/2017/04/14/writing-a-binary-parser-in-python-numpy-vs-construct.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/main.css" /><link type="application/atom+xml" rel="alternate" href="https://kinoshita.eti.br/feed.xml" title="kinow" /><link href="https://unpkg.com/pattern.css" rel="stylesheet" />

</head>
<body>
<div id="mobile-menu"><div class="menu">
  <ul class="menu">
    <li class="item">
      <h1 id="kinow">KINOW</h1>
    </li>
    <li class="item">
      <a href="/" class="">About</a>
    </li>
    <li class="item">
      <a href="/blog/" class="current">Blog</a>
    </li>
    <li class="item">
      <a href="/portfolio/" class="">Portfolio</a>
    </li>
    <li class="item social-media-item">
      <a href="https://www.instagram.com/brunokinoshita/" class="inline-link">
        <img src="/assets/icons/instagram.png" class="inverted-image" />
      </a>
      <a href="https://twitter.com/kinow/" class="inline-link">
        <img src="/assets/icons/twitter.png" class="inverted-image" />
      </a>
      <a href="https://github.com/kinow/" class="inline-link">
        <img src="/assets/icons/github.png" class="inverted-image" />
      </a>
    </li>
  </ul>
</div>
</div>
<div id="wrapper">
  <div id="sidebar"><div class="menu">
  <ul class="menu">
    <li class="item">
      <h1 id="kinow">KINOW</h1>
    </li>
    <li class="item">
      <a href="/" class="">About</a>
    </li>
    <li class="item">
      <a href="/blog/" class="current">Blog</a>
    </li>
    <li class="item">
      <a href="/portfolio/" class="">Portfolio</a>
    </li>
    <li class="item social-media-item">
      <a href="https://www.instagram.com/brunokinoshita/" class="inline-link">
        <img src="/assets/icons/instagram.png" class="inverted-image" />
      </a>
      <a href="https://twitter.com/kinow/" class="inline-link">
        <img src="/assets/icons/twitter.png" class="inverted-image" />
      </a>
      <a href="https://github.com/kinow/" class="inline-link">
        <img src="/assets/icons/github.png" class="inverted-image" />
      </a>
    </li>
  </ul>
</div>
</div>
  <div id="content">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Writing a binary parser in Python: NumPy vs. Construct</h1>
    <span class="post-meta">
      <time class="dt-published" datetime="2017-04-14T00:00:00+12:00" itemprop="datePublished">Apr 14, 2017
      </time>
      <span>&mdash; star date: -305635.62.</span>
      <span>
        Number of words: 610.
      </span></span>
  </header>

  


  <div class="post-content e-content" itemprop="articleBody">
    <p>Some time ago I worked with researchers to write a parser for an old data format. The data
was generated by device (radiosonde) using the vendor (Vaisala) specific binary format.</p>

<p>One of the researchers told me someone had written a parser for his work, and shared it
on GitHub. To be honest, that was my first time parsing data in binary with Python. Did
that before with C, C++, Perl, and Java, but never with Python.</p>

<p>The code on GitHub used <a href="http://www.numpy.org/">NumPy</a> and looked similar to this one.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">parse_header</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dtype</span><span class="p">(</span> <span class="p">[</span> <span class="p">((</span><span class="s">'field_a'</span><span class="p">,</span> <span class="s">'b1'</span><span class="p">),</span> <span class="p">(</span><span class="s">'field_b'</span><span class="p">,</span> <span class="s">'17b1'</span><span class="p">)</span> <span class="p">]</span> <span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.dat'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">header</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">parse_header</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># ...
</span></code></pre></div></div>

<p>And it indeed worked fine. But in the end I used the code - after contacting the author and letting
him know what I was about to do - as reference together with an old specification document
for the format, and created a parser with <a href="https://construct.readthedocs.io/en/latest/">Construct</a>.</p>

<p>From Construct’s website:</p>

<blockquote>
  <p>Construct is a powerful declarative parser (and builder) for binary data.</p>
</blockquote>

<p>This is what the code with construct looked like.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">construct</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">parse_header</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="s">"parse_header"</span><span class="p">,</span>
    <span class="n">Enum</span><span class="p">(</span><span class="n">Byte</span><span class="p">(</span><span class="s">"file_ready"</span><span class="p">),</span>
        <span class="n">READY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">NOT_READY</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_default_</span> <span class="o">=</span> <span class="s">"UNKNOWN"</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">Bytes</span><span class="p">(</span><span class="s">"reserved"</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1"># ...
</span>
<span class="n">parse_contents</span> <span class="o">=</span> <span class="n">Struct</span><span class="p">(</span><span class="s">"parse_contents"</span><span class="p">,</span>
    <span class="n">parse_header</span><span class="p">,</span>
    <span class="n">Range</span><span class="p">(</span><span class="n">mincount</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxcout</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">subcon</span><span class="o">=</span><span class="n">pre_data</span><span class="p">),</span>
    <span class="n">OptionalGreedyRange</span><span class="p">(</span><span class="n">detailed_data</span><span class="p">)</span>
<span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'input.dat'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">parse_results</span> <span class="o">=</span> <span class="n">parse_contents</span><span class="p">.</span><span class="n">parse_stream</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>
    <span class="c1"># ...
</span></code></pre></div></div>

<p>Writing the parser with NumPy or Construct would achieve the same result. However, in the end
this came down to personal preference, and my point of view as Software Engineer. This is the
description of NumPy.</p>

<blockquote>
  <p>NumPy is the fundamental package for scientific computing with Python.</p>
</blockquote>

<p>NumPy is a project tailored for scientific computing, with a focus on linear algebra,
N-dimensional arrays, and so it goes. While it contains code that can parse binary data,
the footprint added to a project that includes it as dependency is quite big.</p>

<p>The parser written with NumPy wasn’t using 5% of the NumPy code base. Probably less than 1%. Updates
to NumPy could break the application compatibility, even if the update came due to some new
matrix operation added to NumPy through some external and missing dependency.</p>

<p>In Java something similar happens with Google Guava. While I use it some times, most of the
times I find myself using one of the Apache Commons libraries, or another dependency
with just what I need. To avoid including unnecessary code to my application.</p>

<p>If you prefer to use NumPy that’s fine too :-) I just had the time enough to rewrite it
instead of using the NumPy (took a couple of hours). In other cases it may still
make sense to use another tool or library, even if it was not made specifically for the
job ¯\<em>(ツ)</em>/¯</p>

<p>♥ Open Source</p>

  </div>

  <div class="tags"><p>Tags:&nbsp;<a class="label" href="/tag/python">python</a>,&nbsp;<a class="label" href="/tag/programming">programming</a>,&nbsp;<a class="label" href="/tag/opensource">opensource</a>.<br/></p></div>

  <a class="u-url" href="/2017/04/14/writing-a-binary-parser-in-python-numpy-vs-construct.html" hidden></a>
</article>

  </div>
</div>
</body>
</html>
